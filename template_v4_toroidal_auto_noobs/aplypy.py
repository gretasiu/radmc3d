'''
What is this script used for?
This is the automated procress to plot PA on I figure after tunning the model in radmc3d

Input: 1300um and 7000um IQU fits files generated by radmc3d imaging

Output:
1. Removing the third axes (frequency axis) from the UIQ fits files generated by radmc3d  
2. APLpy readable IQU, PA, PI, Per fits files. 
3. Plotting PA on I using APLpy and saving the figure in pdf format
'''
import sys
import os
parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'utils'))
#parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
sys.path.append(parent_dir)

import os
import numpy as np

import utils

from astropy.io.fits import getdata
from astropy import wcs
from astropy.io import fits
from astropy import units as u
from astropy import constants as con
from astropy.coordinates import SkyCoord

import matplotlib
import matplotlib.pyplot as plt
import matplotlib as mpl
import matplotlib

import aplpy

matplotlib.use('PDF')

##########################################################################################################
# Work on which wavelength?
##########################################################################################################

image1300 = True
image7000 = True

##########################################################################################################
# Removing the frequency axes in header from IQU fits files generated by radmc3d
##########################################################################################################

if image1300 == True and image7000 == True:
    infiles = ['radmc3d_1300_I.fits', 'radmc3d_1300_Q.fits', 'radmc3d_1300_U.fits',
               'radmc3d_7000_I.fits', 'radmc3d_7000_Q.fits', 'radmc3d_7000_U.fits']
    outfiles = ['radmc3d_1300_I.fits', 'radmc3d_1300_Q.fits', 'radmc3d_1300_U.fits',
                'radmc3d_7000_I.fits', 'radmc3d_7000_Q.fits', 'radmc3d_7000_U.fits']

elif image1300 == True and image7000 == False:
    infiles = ['radmc3d_1300_I.fits',
               'radmc3d_1300_Q.fits', 'radmc3d_1300_U.fits']
    outfiles = ['radmc3d_1300_I.fits',
                'radmc3d_1300_Q.fits', 'radmc3d_1300_U.fits']

elif image1300 == False and image7000 == True:
    infiles = ['radmc3d_7000_I.fits',
               'radmc3d_7000_Q.fits', 'radmc3d_7000_U.fits']
    outfiles = ['radmc3d_7000_I.fits',
                'radmc3d_7000_Q.fits', 'radmc3d_7000_U.fits']

else:
    print("Select at least one wavelength to proceed!")

n = 0
for infile in infiles:
    d, h = fits.getdata(infile, header=True)

    try:
        for i in ['CDELT', 'CRPIX', 'CTYPE', 'CUNIT', 'CRVAL']:
            h.remove(f'{i}3')
    except:
        print("The third axes in", infile,
              "have already been removed.")

    fits.writeto(outfiles[n], data=d, header=h, overwrite=True)
    n += 1

##########################################################################################################
# Creating APLpy readale IQU, PA, Per, PI fits files
##########################################################################################################

if image1300 == True:
    fig1300 = utils.polarization_map(
        source='radmc3d_1300', render='I', step=30, const_pfrac=True, scale=10)

if image7000 == True:
    fig7000 = utils.polarization_map(
        source='radmc3d_7000', render='I', step=30, const_pfrac=True, scale=10)

# In radmc3d output, since I rotate the imaging angle to get a tilted field,
# there will be some pixels without values, and radmc3d will set all these pixels to 0.
# we have to set this value to nan since they are not real.
PAhdu = fits.open('radmc3d_7000_pa.fits')
PAhdu[0].data[PAhdu[0].data == 0] = np.nan
print(PAhdu[0].data)
PAhdu.writeto('radmc3d_7000_pa.fits', overwrite=True)

##########################################################################################################
# Plotting ALMA 1300mm PA on I
##########################################################################################################
if image1300 == True:
    intensitymap = 'radmc3d_1300_I.fits'
    intensity_scale = 1.0
    if_success = False
    try:

        # importing FITS image to a HDU
        Ihdu = fits.open(intensitymap)

        # editing the FITS image by multiplying a scaling factor
        Ihdu[0].data = Ihdu[0].data * intensity_scale

        if_success = True

    except:
        print(
            'Unable to read the intensity FITS image. Please double check the image file.')
        print(intensitymap)

    if (if_success == True):
        # Reading FITS header
        try:
            naxis1 = Ihdu[0].header['naxis1']
            naxis2 = Ihdu[0].header['naxis2']
            crval1 = Ihdu[0].header['crval1']
            crpix1 = Ihdu[0].header['crpix1']
            cdelt1 = Ihdu[0].header['cdelt1']
            crval2 = Ihdu[0].header['crval2']
            crpix2 = Ihdu[0].header['crpix2']
            cdelt2 = Ihdu[0].header['cdelt2']
            hduwcs = wcs.WCS(Ihdu[0].header)
        except:
            print('Warning. No coordinate headers')

        try:
            bmaj = Ihdu[0].header['bmaj']
            bmin = Ihdu[0].header['bmin']
            bpa = Ihdu[0].header['bpa']
            print("bmaj is", bmaj)
        except:
            print('Warnning. No header for synthesized beam size')

    ###########################
        # Importing PA file
    ###########################

    PA_ALMA_file = 'radmc3d_1300_pa.fits'
    PA_ALMA_hdu = fits.open(PA_ALMA_file)

    naxis1_PA_ALMA = PA_ALMA_hdu[0].header['naxis1']
    naxis2_PA_ALMA = PA_ALMA_hdu[0].header['naxis2']
    crval1_PA_ALMA = PA_ALMA_hdu[0].header['crval1']
    crpix1_PA_ALMA = PA_ALMA_hdu[0].header['crpix1']
    cdelt1_PA_ALMA = PA_ALMA_hdu[0].header['cdelt1']
    crval2_PA_ALMA = PA_ALMA_hdu[0].header['crval2']
    crpix2_PA_ALMA = PA_ALMA_hdu[0].header['crpix2']
    cdelt2_PA_ALMA = PA_ALMA_hdu[0].header['cdelt2']
    hduwcs_PA_ALMA = wcs.WCS(PA_ALMA_hdu[0].header)

    ##########################
    # wcs to xy converter
    ##########################
    # center of the figure is (xpix_temp, ypix_temp)
    xpix_temp = int(round(naxis1/2.0-3))
    ypix_temp = int(round(naxis2/2.0+2))

    world = hduwcs.wcs_pix2world([[xpix_temp, ypix_temp]], 0)
    ra_center_zoom = world[0][0]
    dec_center_zoom = world[0][1]

    pixcrd = hduwcs.wcs_world2pix([[ra_center_zoom, dec_center_zoom]], 0)
    ra_center_pix = pixcrd[0][0]
    dec_center_pix = pixcrd[0][1]

    print(ra_center_zoom, dec_center_zoom)

    def plot_intensity(figsize=[8.0, 8.0],
                       plot_intensity=True,
                       intensity_scale=1.0,
                       vmax=-999.0, vmin=0.0,
                       cmap='viridis',
                       plot_ticks=False,
                       tick_font=15,
                       tick_ypad=0,
                       plot_colorbar=True,
                       colorbar_location='top',
                       colorbar_width=0.17, colorbar_pad=0.2, colorbar_font=15,
                       colorbar_label='Colorbar', colorbar_labelpad=8, colorbar_labelfont=15,
                       ra_center=1, dec_center=1, width=1.0, height=1.0,
                       plot_scalebar=False,
                       distance=140,
                       scalebar_size=100, scalebar_text='5000 AU',
                       scalebar_color='gray',
                       scalebar_font=15.0, scalebar_linewidth=3.0,
                       plot_beam=True, beam_color='gray'
                       ):

        #############################
        # Plotting intensity map
        #############################

        if_plot = False
        try:
            fig = aplpy.FITSFigure(Ihdu, figsize=(figsize[0], figsize[1]))
            if_plot = True

        except:
            print('Unable to load or plot hdu. Please double check the image file.')

        if (if_plot == True):
            if (vmax == -999.0):
                vmax = np.nanmax(Ihdu[0].data)*1.2
                vmin = 0.0

            fig.show_colorscale(
                vmax=vmax, vmin=vmin,
                interpolation='bicubic',
                cmap=cmap
            )

        # ticks
        fig.tick_labels.set_font(size=tick_font)
        fig.axis_labels.set_font(size=tick_font)
        fig.axis_labels.set_ypad(tick_ypad)

        if (plot_ticks != True):
            fig.axis_labels.hide_x()
            fig.axis_labels.hide_y()
            fig.tick_labels.hide_x()
            fig.tick_labels.hide_y()

        # plot color bar
        if (plot_colorbar == True):
            fig.add_colorbar()
            fig.colorbar.show()
            fig.colorbar.set_box([0.12, 0.88, 0.75, 0.02],
                                 box_orientation='horizontal')
            fig.colorbar.set_location(colorbar_location)
            fig.colorbar.set_width(colorbar_width)
            fig.colorbar.set_pad(colorbar_pad)
            fig.colorbar.set_font(size=colorbar_font, weight='medium',
                                  stretch='normal', family='sans-serif',
                                  style='normal', variant='normal')
            fig.colorbar.set_axis_label_text(colorbar_label)
            fig.colorbar.set_axis_label_font(size=colorbar_labelfont)
            fig.colorbar.set_axis_label_pad(colorbar_labelpad)

    #     # recentering
    #     if ((ra_center != 0) or (dec_center != 0)):
    #         print('recentering')
    #         #fig.recenter(ra_center, dec_center, width=width, height=height)
    #         fig.recenter(ra_center_zoom, dec_center_zoom,
    #                      width=0.004, height=0.004)  # degrees
    # # width=0.006, height=0.006

        # # plot synthesized beam
        # if (plot_beam == True):
        #     fig.add_beam()
        #     fig.beam.set_color(beam_color)

        # plot scalebar
        if (plot_scalebar == True):

            # fig.add_scalebar(4*scalebar_size * (1.0/distance) / 3600.0)
            fig.add_scalebar(2.7887 / 3600.0)
            fig.scalebar.set_label('0.05 pc')
            fig.scalebar.set_color(scalebar_color)
            fig.scalebar.set_font(size=scalebar_font)
            fig.scalebar.set_linewidth(scalebar_linewidth)

        # # show contour
        # fig.show_contour(Ihdu)

        # # show legend
        # G31_label_pos = hduwcs.wcs_pix2world([[219.6, 264]], 0)
        # JVLA_label_pos = hduwcs.wcs_pix2world([[216.77, 261]], 0)
        # ALMA_label_pos = hduwcs.wcs_pix2world([[217.6, 259]], 0)

        # fig.add_label(ALMA_label_pos[0][0], ALMA_label_pos[0]
        #               [1], '- 1.3mm', color='#FFA500', size=15)
        # fig.add_label(JVLA_label_pos[0][0], JVLA_label_pos[0]
        #               [1], '- 7mm', color=(1, 1, 1), size=15)
        # fig.add_label(G31_label_pos[0][0], G31_label_pos[0]
        #               [1], 'G31.41-0.31', color='gray', size=17)

    #######################################
        # Plotting line segment for ALMA
    #######################################

        length_arcsec = -999.0
        color = (1, 1, 1)
        linestyle = 'solid'
        linewidth = 2
        delraperyr_mas = 0.0
        deldecperyr_mas = 0.0
        delyr = 0.0
        bmaj = 0.3
        bmin = 0.3

        delra_deg = delraperyr_mas * delyr * 0.001 / 3600.0
        deldec_deg = deldecperyr_mas * delyr * 0.001 / 3600.0
        delra_pix = delra_deg / cdelt1
        deldec_pix = deldec_deg / cdelt2

        if (length_arcsec == -999.0):
            length_arcsec = (np.sqrt(bmaj * bmin) * 3600.0) / 3000
            # length_arcsec = bmaj/ 3.3

        halflength_pix = 0.5 * length_arcsec / (cdelt2 * 3600.0)

        xpixgrid_list_ALMA = np.arange(0, 1000, 1)
        ypixgrid_list_ALMA = np.arange(0, 1000, 1)

        for n in range(0, 1000, 50):
            for m in range(0, 1000, 50):
                xpix_ALMA = int(round(xpixgrid_list_ALMA[n]))
                ypix_ALMA = int(round(ypixgrid_list_ALMA[m]))
                pa_ALMA = PA_ALMA_hdu[0].data[ypix_ALMA][xpix_ALMA]

                xbeg_ALMA = xpixgrid_list_ALMA[n] + delra_pix - \
                    halflength_pix * np.sin(np.pi * (pa_ALMA/180.0))
                ybeg_ALMA = ypixgrid_list_ALMA[m] + deldec_pix + \
                    halflength_pix * np.cos(np.pi * (pa_ALMA/180.0))
                xend_ALMA = xpixgrid_list_ALMA[n] + delra_pix + \
                    halflength_pix * np.sin(np.pi * (pa_ALMA/180.0))
                yend_ALMA = ypixgrid_list_ALMA[m] + deldec_pix - \
                    halflength_pix * np.cos(np.pi * (pa_ALMA/180.0))

                world1_ALMA = hduwcs_PA_ALMA.wcs_pix2world(
                    [[xbeg_ALMA, ybeg_ALMA]], 0)
                world2_ALMA = hduwcs_PA_ALMA.wcs_pix2world(
                    [[xend_ALMA, yend_ALMA]], 0)

                linelist_ALMA = [np.array([
                    [world1_ALMA[0][0], world2_ALMA[0][0]],
                    [world1_ALMA[0][1], world2_ALMA[0][1]]
                ])]

                if (np.isfinite(pa_ALMA) == True):
                    fig.show_lines(linelist_ALMA,
                                   color='#FFA500', linestyle=linestyle, linewidth=linewidth)

    #############################
        # Saving the figure
    #############################
        outfigname = 'fig/1300_PA_on_I.pdf'
        fig.save(outfigname, transparent=True)

    plot_intensity(cmap='GnBu', colorbar_label='(Jy/pixel)')


##########################################################################################################
# Plotting JVLA 7000mm PA on I
##########################################################################################################
if image7000 == True:
    intensitymap = 'radmc3d_7000_I.fits'
    intensity_scale = 1.0
    if_success = False
    try:

        # importing FITS image to a HDU
        Ihdu = fits.open(intensitymap)

        # editing the FITS image by multiplying a scaling factor
        Ihdu[0].data = Ihdu[0].data * intensity_scale

        if_success = True

    except:
        print(
            'Unable to read the intensity FITS image. Please double check the image file.')
        print(intensitymap)

    if (if_success == True):
        # Reading FITS header
        try:
            naxis1 = Ihdu[0].header['naxis1']
            naxis2 = Ihdu[0].header['naxis2']
            crval1 = Ihdu[0].header['crval1']
            crpix1 = Ihdu[0].header['crpix1']
            cdelt1 = Ihdu[0].header['cdelt1']
            crval2 = Ihdu[0].header['crval2']
            crpix2 = Ihdu[0].header['crpix2']
            cdelt2 = Ihdu[0].header['cdelt2']
            hduwcs = wcs.WCS(Ihdu[0].header)
        except:
            print('Warning. No coordinate headers')

        try:
            bmaj = Ihdu[0].header['bmaj']
            bmin = Ihdu[0].header['bmin']
            bpa = Ihdu[0].header['bpa']
            print("bmaj is", bmaj)
        except:
            print('Warnning. No header for synthesized beam size')

    ################################
        # Importing PA file
    ################################
    # ALMA
    PA_ALMA_file = 'radmc3d_7000_pa.fits'
    PA_ALMA_hdu = fits.open(PA_ALMA_file)
    print(PA_ALMA_hdu[0].data)

    naxis1_PA_ALMA = PA_ALMA_hdu[0].header['naxis1']
    naxis2_PA_ALMA = PA_ALMA_hdu[0].header['naxis2']
    crval1_PA_ALMA = PA_ALMA_hdu[0].header['crval1']
    crpix1_PA_ALMA = PA_ALMA_hdu[0].header['crpix1']
    cdelt1_PA_ALMA = PA_ALMA_hdu[0].header['cdelt1']
    crval2_PA_ALMA = PA_ALMA_hdu[0].header['crval2']
    crpix2_PA_ALMA = PA_ALMA_hdu[0].header['crpix2']
    cdelt2_PA_ALMA = PA_ALMA_hdu[0].header['cdelt2']
    hduwcs_PA_ALMA = wcs.WCS(PA_ALMA_hdu[0].header)

    ###############################
    # wcs to xy converter
    ###############################
    # center of the figure is (xpix_temp, ypix_temp)
    xpix_temp = int(round(naxis1/2.0-3))
    ypix_temp = int(round(naxis2/2.0+2))

    world = hduwcs.wcs_pix2world([[xpix_temp, ypix_temp]], 0)
    ra_center_zoom = world[0][0]
    dec_center_zoom = world[0][1]

    pixcrd = hduwcs.wcs_world2pix([[ra_center_zoom, dec_center_zoom]], 0)
    ra_center_pix = pixcrd[0][0]
    dec_center_pix = pixcrd[0][1]

    print(ra_center_zoom, dec_center_zoom)

    def plot_intensity(figsize=[8.0, 8.0],
                       plot_intensity=True,
                       intensity_scale=1.0,
                       vmax=-999.0, vmin=0.0,
                       cmap='viridis',
                       plot_ticks=False,
                       tick_font=15,
                       tick_ypad=0,
                       plot_colorbar=True,
                       colorbar_location='top',
                       colorbar_width=0.17, colorbar_pad=0.2, colorbar_font=15,
                       colorbar_label='Colorbar', colorbar_labelpad=8, colorbar_labelfont=15,
                       ra_center=1, dec_center=1, width=1.0, height=1.0,
                       plot_scalebar=False,
                       distance=140,
                       scalebar_size=100, scalebar_text='5000 AU',
                       scalebar_color='gray',
                       scalebar_font=15.0, scalebar_linewidth=3.0,
                       plot_beam=True, beam_color='gray'
                       ):

        #############################
        # Plotting intensity map
        #############################

        if_plot = False
        try:
            fig = aplpy.FITSFigure(Ihdu, figsize=(figsize[0], figsize[1]))
            if_plot = True

        except:
            print('Unable to load or plot hdu. Please double check the image file.')

        if (if_plot == True):
            if (vmax == -999.0):
                vmax = np.nanmax(Ihdu[0].data)*1.2
                vmin = 0.0

            fig.show_colorscale(
                vmax=vmax, vmin=vmin,
                interpolation='bicubic',
                cmap=cmap
            )

        # ticks
        fig.tick_labels.set_font(size=tick_font)
        fig.axis_labels.set_font(size=tick_font)
        fig.axis_labels.set_ypad(tick_ypad)

        if (plot_ticks != True):
            fig.axis_labels.hide_x()
            fig.axis_labels.hide_y()
            fig.tick_labels.hide_x()
            fig.tick_labels.hide_y()

        # plot color bar
        if (plot_colorbar == True):
            fig.add_colorbar()
            fig.colorbar.show()
            fig.colorbar.set_box([0.12, 0.88, 0.75, 0.02],
                                 box_orientation='horizontal')
            fig.colorbar.set_location(colorbar_location)
            fig.colorbar.set_width(colorbar_width)
            fig.colorbar.set_pad(colorbar_pad)
            fig.colorbar.set_font(size=colorbar_font, weight='medium',
                                  stretch='normal', family='sans-serif',
                                  style='normal', variant='normal')
            fig.colorbar.set_axis_label_text(colorbar_label)
            fig.colorbar.set_axis_label_font(size=colorbar_labelfont)
            fig.colorbar.set_axis_label_pad(colorbar_labelpad)

    #     # recentering
    #     if ((ra_center != 0) or (dec_center != 0)):
    #         print('recentering')
    #         #fig.recenter(ra_center, dec_center, width=width, height=height)
    #         fig.recenter(ra_center_zoom, dec_center_zoom,
    #                      width=0.004, height=0.004)  # degrees
    # # width=0.006, height=0.006

        # # plot synthesized beam
        # if (plot_beam == True):
        #     fig.add_beam()
        #     fig.beam.set_color(beam_color)

        # plot scalebar
        if (plot_scalebar == True):

            # fig.add_scalebar(4*scalebar_size * (1.0/distance) / 3600.0)
            fig.add_scalebar(2.7887 / 3600.0)
            fig.scalebar.set_label('0.05 pc')
            fig.scalebar.set_color(scalebar_color)
            fig.scalebar.set_font(size=scalebar_font)
            fig.scalebar.set_linewidth(scalebar_linewidth)

        # # show contour
        # fig.show_contour(Ihdu)

        # # show legend
        # G31_label_pos = hduwcs.wcs_pix2world([[219.6, 264]], 0)
        # JVLA_label_pos = hduwcs.wcs_pix2world([[216.77, 261]], 0)
        # ALMA_label_pos = hduwcs.wcs_pix2world([[217.6, 259]], 0)

        # fig.add_label(ALMA_label_pos[0][0], ALMA_label_pos[0]
        #               [1], '- 1.3mm', color='#FFA500', size=15)
        # fig.add_label(JVLA_label_pos[0][0], JVLA_label_pos[0]
        #               [1], '- 7mm', color=(1, 1, 1), size=15)
        # fig.add_label(G31_label_pos[0][0], G31_label_pos[0]
        #               [1], 'G31.41-0.31', color='gray', size=17)

    #######################################
        # Plotting line segment for ALMA
    #######################################

        length_arcsec = -999.0
        color = (1, 1, 1)
        linestyle = 'solid'
        linewidth = 2
        delraperyr_mas = 0.0
        deldecperyr_mas = 0.0
        delyr = 0.0
        bmaj = 0.3
        bmin = 0.3

        delra_deg = delraperyr_mas * delyr * 0.001 / 3600.0
        deldec_deg = deldecperyr_mas * delyr * 0.001 / 3600.0
        delra_pix = delra_deg / cdelt1
        deldec_pix = deldec_deg / cdelt2

        if (length_arcsec == -999.0):
            length_arcsec = (np.sqrt(bmaj * bmin) * 3600.0) / 3500
            # length_arcsec = bmaj/ 3.3

        halflength_pix = 0.5 * length_arcsec / (cdelt2 * 3600.0)

        xpixgrid_list_ALMA = np.arange(0, 1000, 1)
        ypixgrid_list_ALMA = np.arange(0, 1000, 1)

        for n in range(0, 1000, 50):
            for m in range(0, 1000, 50):
                xpix_ALMA = int(round(xpixgrid_list_ALMA[n]))
                ypix_ALMA = int(round(ypixgrid_list_ALMA[m]))
                pa_ALMA = PA_ALMA_hdu[0].data[ypix_ALMA][xpix_ALMA]

                xbeg_ALMA = xpixgrid_list_ALMA[n] + delra_pix - \
                    halflength_pix * np.sin(np.pi * (pa_ALMA/180.0))
                ybeg_ALMA = ypixgrid_list_ALMA[m] + deldec_pix + \
                    halflength_pix * np.cos(np.pi * (pa_ALMA/180.0))
                xend_ALMA = xpixgrid_list_ALMA[n] + delra_pix + \
                    halflength_pix * np.sin(np.pi * (pa_ALMA/180.0))
                yend_ALMA = ypixgrid_list_ALMA[m] + deldec_pix - \
                    halflength_pix * np.cos(np.pi * (pa_ALMA/180.0))

                world1_ALMA = hduwcs_PA_ALMA.wcs_pix2world(
                    [[xbeg_ALMA, ybeg_ALMA]], 0)
                world2_ALMA = hduwcs_PA_ALMA.wcs_pix2world(
                    [[xend_ALMA, yend_ALMA]], 0)

                linelist_ALMA = [np.array([
                    [world1_ALMA[0][0], world2_ALMA[0][0]],
                    [world1_ALMA[0][1], world2_ALMA[0][1]]
                ])]

                if (np.isfinite(pa_ALMA) == True):
                    fig.show_lines(linelist_ALMA,
                                   color='#FFA500', linestyle=linestyle, linewidth=linewidth)

    #############################
        # Saving the figure
    #############################
        outfigname = 'fig/7000_PA_on_I.pdf'
        fig.save(outfigname, transparent=True)

    plot_intensity(cmap='GnBu', colorbar_label='(Jy/pixel)')
